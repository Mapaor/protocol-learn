import { Protocol } from "../../types/protocol";

export const OSPF: Protocol = {
    id: "ospf",
    name: "OSPF",
    category: "Network",
    difficulty: "Advanced",
    shortDescription: "Open Shortest Path First routing protocol for IP networks",
    fullDescription: "OSPF (Open Shortest Path First) is a routing protocol for Internet Protocol networks. It uses a link state routing algorithm and falls into the group of interior gateway protocols, operating within a single autonomous system. OSPF builds a topology database and uses Dijkstra's algorithm to calculate shortest paths.",
    port: "N/A (IP Protocol 89)",
    advantages: [
      "Fast convergence",
      "Hierarchical design",
      "Load balancing",
      "Authentication support",
      "VLSM support",
      "Scalable architecture"
    ],
    disadvantages: [
      "Complex configuration",
      "High memory usage",
      "CPU intensive",
      "Difficult troubleshooting",
      "Area design complexity",
      "LSA flooding overhead"
    ],
    useCases: [
      "Enterprise networks",
      "ISP networks",
      "Data center routing",
      "Campus networks",
      "WAN connectivity",
      "Multi-area networks",
      "Load balancing",
      "Redundant path selection",
      "Network convergence",
      "Hierarchical routing",
      "MPLS networks",
      "Service provider backbone"
    ],
    examples: [
      {
        title: "OSPF Packet Types and Headers",
        code: `# OSPF Packet Header (24 bytes)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Version #   |     Type      |         Packet length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Router ID                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Area ID                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |             AuType            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Authentication                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Authentication                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# OSPF Packet Types
Type 1: Hello Packet (neighbor discovery and maintenance)
Type 2: Database Description (DBD) - topology database summary
Type 3: Link State Request (LSR) - request specific LSAs
Type 4: Link State Update (LSU) - contains LSAs
Type 5: Link State Acknowledgment (LSAck) - acknowledge LSAs

# Hello Packet Format
Hello Packet:
- Network Mask: 255.255.255.0
- Hello Interval: 10 seconds
- Router Dead Interval: 40 seconds  
- Designated Router: 192.168.1.1
- Backup Designated Router: 192.168.1.2
- Neighbor List: [192.168.1.3, 192.168.1.4]

# LSA Types
Type 1: Router LSA (generated by each router)
Type 2: Network LSA (generated by DR on multi-access networks)
Type 3: Summary LSA (generated by ABR for inter-area routes)
Type 4: ASBR Summary LSA (path to ASBR)
Type 5: AS External LSA (external routes)
Type 7: NSSA External LSA (Not-So-Stubby Area)

# OSPF States
Down -> Init -> 2-Way -> ExStart -> Exchange -> Loading -> Full

# Area Types
- Backbone Area (Area 0)
- Standard Area
- Stub Area (no external LSAs)
- Totally Stubby Area (no external or summary LSAs)
- NSSA (Not-So-Stubby Area)`,
        explanation: "OSPF packet structure, types, and fundamental concepts."
      },
      {
        title: "OSPF Configuration Example",
        code: `# Cisco OSPF Configuration

# Basic OSPF Configuration
router ospf 1
 router-id 1.1.1.1
 network 192.168.1.0 0.0.0.255 area 0
 network 10.0.0.0 0.255.255.255 area 1
 passive-interface FastEthernet0/0

# Interface-specific OSPF configuration
interface FastEthernet0/1
 ip ospf cost 100
 ip ospf hello-interval 5
 ip ospf dead-interval 20
 ip ospf priority 10
 ip ospf authentication message-digest
 ip ospf message-digest-key 1 md5 MySecretKey

# Area configuration
router ospf 1
 area 1 stub
 area 2 nssa
 area 3 stub no-summary
 area 0 authentication message-digest

# Default route distribution
router ospf 1
 default-information originate always metric 1

# Route redistribution
router ospf 1
 redistribute static subnets
 redistribute connected subnets
 redistribute rip metric 20 subnets

# Linux OSPF with Quagga/FRR
# /etc/quagga/ospfd.conf
router ospf
 ospf router-id 2.2.2.2
 network 192.168.1.0/24 area 0.0.0.0
 network 10.0.0.0/8 area 0.0.0.1
 area 0.0.0.1 stub
 
interface eth0
 ip ospf cost 10
 ip ospf hello-interval 10
 ip ospf dead-interval 40

# Start OSPF daemon
systemctl start ospfd
systemctl enable ospfd

# View OSPF information
vtysh
show ip ospf neighbor
show ip ospf database
show ip ospf interface
show ip ospf route

# Python OSPF monitoring
import subprocess
import re

def get_ospf_neighbors():
    result = subprocess.run(['vtysh', '-c', 'show ip ospf neighbor'], 
                          capture_output=True, text=True)
    neighbors = []
    for line in result.stdout.split('\\n'):
        if re.match(r'^\\d+\\.\\d+\\.\\d+\\.\\d+', line):
            parts = line.split()
            neighbor = {
                'neighbor_id': parts[0],
                'priority': parts[1], 
                'state': parts[2],
                'dead_time': parts[3],
                'address': parts[4],
                'interface': parts[5]
            }
            neighbors.append(neighbor)
    return neighbors

def get_ospf_database():
    result = subprocess.run(['vtysh', '-c', 'show ip ospf database'], 
                          capture_output=True, text=True)
    return result.stdout`,
        explanation: "OSPF configuration on Cisco routers and Linux systems."
      },
      {
        title: "OSPF LSA Analysis",
        code: `# OSPF Link State Advertisement (LSA) Structure

# LSA Header (20 bytes)
LSA Header:
- LS Age: 300 seconds
- Options: 0x22 (E-bit, DC-bit)
- LS Type: 1 (Router LSA)
- Link State ID: 1.1.1.1
- Advertising Router: 1.1.1.1
- LS Sequence Number: 0x80000001
- LS Checksum: 0x1234
- Length: 48 bytes

# Type 1 Router LSA
Router LSA:
- Flags: ABR, ASBR
- Number of Links: 2
- Link 1:
  - Link ID: 192.168.1.1 (IP of DR)
  - Link Data: 192.168.1.2 (Router's IP)
  - Type: Transit Network
  - Metric: 10
- Link 2:
  - Link ID: 10.0.0.2
  - Link Data: 255.255.255.252
  - Type: Point-to-Point
  - Metric: 100

# Type 2 Network LSA (from DR)
Network LSA:
- Network Mask: 255.255.255.0
- Attached Routers: [1.1.1.1, 2.2.2.2, 3.3.3.3]

# Type 3 Summary LSA (from ABR)
Summary LSA:
- Network Mask: 255.255.255.0
- Metric: 20

# OSPF Database Analysis Script
#!/bin/bash

# Function to analyze OSPF database
analyze_ospf_db() {
    echo "=== OSPF Database Analysis ==="
    
    # Show all LSAs
    vtysh -c "show ip ospf database"
    
    echo "\\n=== Router LSAs ==="
    vtysh -c "show ip ospf database router"
    
    echo "\\n=== Network LSAs ==="
    vtysh -c "show ip ospf database network"
    
    echo "\\n=== Summary LSAs ==="
    vtysh -c "show ip ospf database summary"
    
    echo "\\n=== External LSAs ==="
    vtysh -c "show ip ospf database external"
    
    echo "\\n=== OSPF Routes ==="
    vtysh -c "show ip ospf route"
    
    echo "\\n=== OSPF Neighbors ==="
    vtysh -c "show ip ospf neighbor detail"
}

# OSPF Troubleshooting Commands
debug_ospf() {
    echo "=== OSPF Debugging ==="
    
    # Check OSPF process
    vtysh -c "show ip ospf"
    
    # Check interface status
    vtysh -c "show ip ospf interface"
    
    # Check neighbor relationships
    vtysh -c "show ip ospf neighbor"
    
    # Check LSA database
    vtysh -c "show ip ospf database"
    
    # Check routing table
    vtysh -c "show ip route ospf"
}

# Python OSPF SPF calculation simulation
import heapq
from collections import defaultdict

class OSPFGraph:
    def __init__(self):
        self.graph = defaultdict(list)
        self.nodes = set()
    
    def add_link(self, router1, router2, cost):
        self.graph[router1].append((router2, cost))
        self.graph[router2].append((router1, cost))
        self.nodes.add(router1)
        self.nodes.add(router2)
    
    def dijkstra(self, start):
        distances = {node: float('inf') for node in self.nodes}
        distances[start] = 0
        previous = {}
        heap = [(0, start)]
        
        while heap:
            current_distance, current = heapq.heappop(heap)
            
            if current_distance > distances[current]:
                continue
                
            for neighbor, weight in self.graph[current]:
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current
                    heapq.heappush(heap, (distance, neighbor))
        
        return distances, previous
    
    def shortest_path(self, start, end):
        distances, previous = self.dijkstra(start)
        path = []
        current = end
        
        while current in previous:
            path.append(current)
            current = previous[current]
        path.append(start)
        
        return path[::-1], distances[end]

# Example usage
ospf_net = OSPFGraph()
ospf_net.add_link('R1', 'R2', 10)
ospf_net.add_link('R1', 'R3', 20)
ospf_net.add_link('R2', 'R4', 15)
ospf_net.add_link('R3', 'R4', 5)

path, cost = ospf_net.shortest_path('R1', 'R4')
print(f"Shortest path from R1 to R4: {' -> '.join(path)}, Cost: {cost}")`,
        explanation: "OSPF LSA structure analysis and SPF algorithm implementation."
      }
    ],
    relatedProtocols: ["bgp", "rip", "eigrp", "ipv4", "ipv6"],
    resources: [
      {
        title: "RFC 2328 - OSPF Version 2",
        url: "https://tools.ietf.org/html/rfc2328",
        type: "RFC"
      },
      {
        title: "RFC 5340 - OSPF for IPv6",
        url: "https://tools.ietf.org/html/rfc5340",
        type: "RFC"
      }
    ],
    securityConsiderations: [
      "Authentication mechanisms",
      "LSA flooding attacks",
      "Neighbor authentication",
      "Area security boundaries",
      "Routing table poisoning",
      "Network reconnaissance"
    ]
};
